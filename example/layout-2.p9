% all the node constants need to be different
((in1 != s7) & (in1 != in2) & (in1 != s4) & (in1 != in3) & (in1 != s5) & (in1 != s2) & (in1 != s3) & (in1 != out1) & (in1 != out2) & (in1 != out3) & (s7 != in2) & (s7 != s4) & (s7 != in3) & (s7 != s5) & (s7 != s2) & (s7 != s3) & (s7 != out1) & (s7 != out2) & (s7 != out3) & (in2 != s4) & (in2 != in3) & (in2 != s5) & (in2 != s2) & (in2 != s3) & (in2 != out1) & (in2 != out2) & (in2 != out3) & (s4 != in3) & (s4 != s5) & (s4 != s2) & (s4 != s3) & (s4 != out1) & (s4 != out2) & (s4 != out3) & (in3 != s5) & (in3 != s2) & (in3 != s3) & (in3 != out1) & (in3 != out2) & (in3 != out3) & (s5 != s2) & (s5 != s3) & (s5 != out1) & (s5 != out2) & (s5 != out3) & (s2 != s3) & (s2 != out1) & (s2 != out2) & (s2 != out3) & (s3 != out1) & (s3 != out2) & (s3 != out3) & (out1 != out2) & (out1 != out3) & (out2 != out3)) # label(nodesAllDiff).
% all and only the node constants are nodes
(all N (node(N) <-> ((N = in1) | (N = s7) | (N = in2) | (N = s4) | (N = in3) | (N = s5) | (N = s2) | (N = s3) | (N = out1) | (N = out2) | (N = out3)))) # label(nodePredicate).

% transition axiom for input node in1
(all X all T (at(succ(X), T, in1) <-> (enter(X, T, in1) | (at(X, T, in1) & (-goes(X, in1) | -open(X, in1)))))) # label(node_in1).
% transition axiom for inner node s7
(all X all T (at(succ(X), T, s7) <-> ((at(X, T, s7) & -goes(X, s7)) | (at(X, T, in1) & goes(X, in1) & open(X, in1))))) # label(node_s7).
% transition axiom for input node in2
(all X all T (at(succ(X), T, in2) <-> (enter(X, T, in2) | (at(X, T, in2) & (-goes(X, in2) | -open(X, in2)))))) # label(node_in2).
% transition axiom for inner node s4
(all X all T (at(succ(X), T, s4) <-> ((at(X, T, s4) & -goes(X, s4)) | (at(X, T, in2) & goes(X, in2) & open(X, in2))))) # label(node_s4).
% transition axiom for input node in3
(all X all T (at(succ(X), T, in3) <-> (enter(X, T, in3) | (at(X, T, in3) & (-goes(X, in3) | -open(X, in3)))))) # label(node_in3).
% transition axiom for inner node s5
(all X all T (at(succ(X), T, s5) <-> ((at(X, T, s5) & -goes(X, s5)) | (at(X, T, in3) & goes(X, in3) & open(X, in3))))) # label(node_s5).
% transition axiom for inner node s2
(all X all T (at(succ(X), T, s2) <-> ((at(X, T, s2) & -goes(X, s2)) | (at(X, T, s7) & goes(X, s7) & (switch(X, s7) = s2)) | (at(X, T, s4) & goes(X, s4) & (switch(X, s4) = s2)) | (at(X, T, s5) & goes(X, s5) & (switch(X, s5) = s2))))) # label(node_s2).
% transition axiom for inner node s3
(all X all T (at(succ(X), T, s3) <-> ((at(X, T, s3) & -goes(X, s3)) | (at(X, T, s7) & goes(X, s7) & (switch(X, s7) = s3)) | (at(X, T, s4) & goes(X, s4) & (switch(X, s4) = s3)) | (at(X, T, s5) & goes(X, s5) & (switch(X, s5) = s3))))) # label(node_s3).
% transition axiom for output node out1
(all X all T (at(succ(X), T, out1) <-> ((at(X, T, s2) & goes(X, s2)) | (at(X, T, s3) & goes(X, s3) & (switch(X, s3) = out1))))) # label(node_out1).
% transition axiom for output node out2
(all X all T (at(succ(X), T, out2) <-> ((at(X, T, s4) & goes(X, s4) & (switch(X, s4) = out2)) | (at(X, T, s5) & goes(X, s5) & (switch(X, s5) = out2)) | (at(X, T, s3) & goes(X, s3) & (switch(X, s3) = out2))))) # label(node_out2).
% transition axiom for output node out3
(all X all T (at(succ(X), T, out3) <-> ((at(X, T, s3) & goes(X, s3) & (switch(X, s3) = out3))))) # label(node_out3).

% no train can be at any two nodes in the same time
(all X all T all N1 all N2 ((at(X, T, N1) & at(X, T, N2)) -> (N1 = N2))) # label(singularTrainLocation).
% the train driver has to go eventually
(all X all T all N (at(X, T, N) -> (exists Y (((X = Y) | less(X, Y)) & goes(Y, N))))) # label(trainDriverGoes).
